import json
import os
import sys
from openai import OpenAI

from pytube import YouTube
import argparse
import requests
from dotenv import load_dotenv

import streamlit as st


load_dotenv()
client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))


def download_audio_from_youtube(url):
    # Load the cache file
    try:
        with open('./data/cache.json', 'r') as f:
            cache = json.load(f)
    except FileNotFoundError:
        cache = {}

    # If the URL is in the cache and the file exists, skip the download
    if url in cache and os.path.exists(cache[url]):
        print(f'URL {url} is in cache, skipping download')
        return cache[url]

    yt = YouTube(url)
    out_file = yt.streams.get_audio_only().download("./data/audio_files/")
    output_mp3 = os.path.splitext(out_file)[0] + '.mp3'
    os.rename(out_file, output_mp3)
    print(f'Audio file downloaded to: {output_mp3}')

    # Add the URL and the file path to the cache and save it
    cache[url] = output_mp3
    with open('./data/cache.json', 'w') as f:
        json.dump(cache, f)

    return output_mp3


def transcribe_audio(audio_file):
    # Load the transcript cache file
    try:
        with open('./data/transcript_cache.json', 'r') as f:
            transcript_cache = json.load(f)
    except FileNotFoundError:
        transcript_cache = {}

    # If the audio file is in the cache and the transcript file exists, skip the transcription
    transcript_file = f"./data/transcripts/{os.path.basename(audio_file)}.txt"
    if audio_file in transcript_cache and os.path.exists(transcript_file):
        print(f'Transcript for audio file {audio_file} is in cache, skipping transcription')
        with open(transcript_file, 'r') as f:
            return f.read()

    with open(audio_file, 'rb') as file:
        transcript = client.audio.transcriptions.create(model='whisper-1', 
        file=file, response_format="text")
    print(f"Transcript from the audio:\n\n{transcript}\n")

    # Save the transcript to a file
    with open(transcript_file, 'w') as f:
        f.write(transcript)

    # Add the audio file and the transcript file path to the cache and save it
    transcript_cache[audio_file] = transcript_file
    with open('./data/transcript_cache.json', 'w') as f:
        json.dump(transcript_cache, f)

    return transcript

def get_transcript_from_youtube(url):
    return transcribe_audio(download_audio_from_youtube(url))

def summarize_transcript(transcript):
    completion = client.chat.completions.create(model="gpt-4-1106-preview",
    messages=[
        {"role": "system", "content": "You are a helpful assistant that "
            "summarizes transcriptions from audio files as though you are the speaker."},
        {"role": "user", "content": (f"First summarize the most important topics "
            f"from the following transcript as though you are the speaker, emphasizing the most critical ideas "
            f"for your telegram channel. Do not reference that you're summarizing a transcript: {transcript}")
        },
    ])

    return completion.choices[0].message.content


def process_audio_source(get_transcript_func, source):

    def write_to_file(filename, content):
        with open(filename, 'w') as f:
            f.write(content)

    transcript = get_transcript_func(source)
    write_to_file('./data/transcripts/transcript.txt', transcript)
    summary = summarize_transcript(transcript)
    print(f"Here is the summary:\n\n{summary}\n")
    write_to_file('./data/transcripts/summary.txt', summary)
    return summary

def handle_youtube_url(url):
    return process_audio_source(get_transcript_from_youtube, url)

def handle_audio_file(audio_file):
    return process_audio_source(transcribe_audio, audio_file)

def post_to_telegram(summary, audio=None):
    TELEGRAM_BOT_API_KEY = os.environ.get('TEST_CHANNEL_9000_BOT_API_KEY')
    MY_CHANNEL_NAME = os.environ.get("TEST_CHANNEL_ID")

    response = requests.get(f'https://api.telegram.org/bot{TELEGRAM_BOT_API_KEY}/sendMessage', {
        'chat_id': MY_CHANNEL_NAME,
        'text': f"{summary}\n\nDisclaimer: the above summary was generated by a large language model. Take it with a grain of salt."
    })

    if not response.status_code == 200:
        print(response.text)

    if audio == None: return

    with open(audio, 'rb') as audio_file:
        response = requests.post(
            f'https://api.telegram.org/bot{TELEGRAM_BOT_API_KEY}/sendAudio',
            data={
                'chat_id': MY_CHANNEL_NAME,
                'title': 'Audio Summary',
                'caption': 'Here is the audio file related to the summary posted earlier.'
            },
            files={
                'audio': audio_file
            }
        )

    if not response.status_code == 200:
        print(response.text)


def main():
    st.title("YouTube Audio Transcriber and Summarizer")

    url = st.text_input("Enter a YouTube URL:")
    audio_file = st.file_uploader("Or upload an audio file:", type=['mp3', 'wav'])

    disable_telegram = st.checkbox("Disable posting to Telegram", value=True)

    if st.button("Process"):
        if url:
            summary = handle_youtube_url(url)
            if not disable_telegram:
                post_to_telegram(summary)
            st.text_area("Summary", summary, height=250)
        elif audio_file:
            # Save the uploaded audio file to a temporary location
            audio_path = f"./data/audio_files/{audio_file.name}"
            with open(audio_path, "wb") as f:
                f.write(audio_file.getbuffer())
            summary = handle_audio_file(audio_path)
            if not disable_telegram:
                post_to_telegram(summary, audio_path)
            st.text_area("Summary", summary, height=250)
        else:
            st.warning("Please enter a URL or upload an audio file.")


if __name__ == '__main__':
    main()